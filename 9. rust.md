## 소유권
가비지 컬렉터 없다면 사용자가 직접 명시적으로 메모리를 할당하고 해제해야함    
-> 러스트의 접근법. 메모리는 컴파일 타임에 컴파일러가 체크할 규칙들로 구성된 소유권 시스템을 통해 관리됨.

### 소유권 규칙
1. 데이터가 변수에 할당되면 변수는 데이터의 ‘owner’가 된다.
2. 한번에 딱 하나의 owner만 존재할 수 있다.
3. owner가 스코프 밖으로 벗어나는 때, 값은 버려진다.

**변수의 스코프**    
함수 블록이 종료될 때 값이 버려짐.    
```rust
{                      
    let s = "hello";   // s는 이 지점부터 유효.
}                      // 이 스코프를 벗어나면, s는 더이상 유효하지 않음.
```
**규칙**
- 기본 자료형의 경우(int, float 등)는 copy가 가능
- 복합 자료형(String, Struct 등)은 소유권을 move(이동).
-> copy가 아니라 clone 해야함

1. 기본 자료형 copy    
스택에 저장되는 타입은 복사 가능    
→ 이미 컴파일 타임에 결정되어 있는 크기의 타입은 스택에 저장되므로 복사본이 빠르게 만들어짐.
![image](https://github.com/leehansori/Fasoo_BigData/assets/109563345/576dc23d-cf73-4d85-b586-3ee043bd1f40)

2. 복합 자료형    
![image](https://github.com/leehansori/Fasoo_BigData/assets/109563345/0373d091-6d64-422b-a7a9-14b521366f4b)
-> copy 안됨. 소유권이 이전(Move)됨.    
![image](https://github.com/leehansori/Fasoo_BigData/assets/109563345/de2637c1-aa05-425e-b7f2-31be6fe29222)

i) 얕은 복사
스택에 있는 포인터, 길이값, 용량값이 복사되고, 힙 메모리 데이터는 복사X    
![image](https://github.com/leehansori/Fasoo_BigData/assets/109563345/7b169a90-14f2-4809-ab0c-d5d227f7c6b7)    
→ 변수 스코프 밖으로 벗어나게 되면, s1, s2 모두 같은 메모리를 해제하려고 해서
두번 해제 오류 생김. 이는 메모리 손상의 원인






