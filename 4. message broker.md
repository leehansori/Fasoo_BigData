---
layout: post
title: "message broker"
등록일: 2023-04-28
수정일: 2023-05-02
author: 이한솔
---

특징, 구조, 동작, 성능(속도, 부하, 어디까지 가능?)


요구사항 : 비동기 처리 가능할 것, 다양한 프로그래밍 언어 client가 있을 것, multiple producer-consumer 가능, 속도가 빠를 것    
→ 핵심은 성능 (속도, 부하).    
성능에 영향을 미치는 요소? 아키텍처와 동작 방법을 확인해 어떤 부분에서 문제가 발생할지 예상, 속도를 빠르게 하고 부하를 줄이기 위한 방법들    

1. kafka
2. redis pub/sub
3. rabbitMQ
4. pulsar

---

## **Kafka**    
> kafka는 pub-sub(메시지를 받기를 원하는 consumer 해당 topic을 구독함으로써 메시지를 읽어옴)방식의 분산형 스트리밍 플랫폼    

<kafka의 목표>
- Producer와 Consumer의 분리
- 메시지 데이터를 영구히 저장하고 여러 Consumer에게 허용
- 높은 처리량을 위한 메시지 최적화
- 데이터가 증가함에 따라 스케일아웃이 가능한 시스템    
(*스케일아웃 : 서버를 여러 대 추가하여 시스템을 확장하는 방법)

<img src="https://user-images.githubusercontent.com/109563345/235531340-bc045761-0c29-4859-a993-0d5796f559c3.png" width="700">

### **1. 동작**    
Topic을 기준으로 메시지를 관리.    
- Producer는 특정 Topic의 메시지를 생성한 뒤 해당 메시지를 Broker에 전달    
- Broker가 전달받은 메시지를 Topic별로 분류하여 쌓아놓으면, 해당 Topic을 구독하는 Consumer들이 메시지를 가져가서 처리    

  **<Topic과 Partition>**    
  하나의 Topic은 여러 Partition으로 구성. 분산 저장해서 시간을 단축시키기 위해        
  Partition안에서는 Offset단위로 나뉘어짐    
  ![image](https://user-images.githubusercontent.com/109563345/235552672-0dfc0d4c-d7c3-4c60-9701-bc2224f81a50.png)


  1) Partition이 1개 이상일 경우    
  데이터는 큐와 같이 순차적으로 쌓이며 Consumer는 들어온 순서대로 가져감. 이때, 가져가더라도 데이터는 삭제되지 않고 파티션에 그대로 남음    
  → 새로운 컨슈머가 왔을 때 0부터 가져 갈 수 있음. 동일한 데이터를 여러 번 처리 가능    
  <img src="https://user-images.githubusercontent.com/109563345/235551292-24eb7b19-bdbe-4924-abd3-09e50e769876.png" width="700">


### **2. 특징**    
- 메시지를 메모리에 저장하지 않고 디스크(파일)에 저장 → 메시지 유실 우려가 감소
- Consumer가 Broker로부터 메시지를 직접 가져가는 PULL 방식으로 동작 → Consumer는 자신의 처리 능력만큼의 메시지만 가져와 최적의 성능


---
참고    
<https://velog.io/@busybean3/%EC%95%84%ED%8C%8C%EC%B9%98-%EC%B9%B4%ED%94%84%EC%B9%B4Apache-Kafka-%EB%9E%80>
<https://velog.io/@cbkyeong/Kafka%ED%86%A0%ED%94%BD%EC%9D%B4%EB%9E%80>
