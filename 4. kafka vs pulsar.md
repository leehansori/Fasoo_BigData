## **Kafka, Pulsar 비교**

### **[성능]**
(1) 처리량 : 네트워크, 디스크, CPU 및 메모리 리소스의 양이 동일할 때 각 시스템이 달성할 수 있는 안정적인 최대 처리량    
(2) 지연 시간 : 메시지가 Producer에서 시스템을 거쳐 Consumer로 통과할 수 있는 종단 간 대기 시간        
**→ Kafka가 Pulsar에 비해 높은 처리량과 낮은 대기 시간을 제공**    
![image](https://user-images.githubusercontent.com/109563345/236927811-d45fac24-d816-45f9-a9a3-aedb8c1561f3.png)
[Confluent Test https://www.confluent.io/blog/kafka-fastest-messaging-system/]    

### **[메시지 소비 방법]**    
Kafka - Pull 방식
- Consumer가 메시지를 직접 요청하여 가져오는 방식
- Pull 방식은 가져올 메시지의 양과 속도를 조절, Consumer가 처리할 수 있는 속도에 맞춰 메시지를 가져올 수 있음

Pulsar - Push 방식
- Broker가 메시지를 Consumer에게 직접 보내는 방식
- Consumer는 Broker에게 메시지를 수신할 준비가 되어 있다고 등록하고, Broker는 해당 Consumer에게 메시지를 푸시.

### **[확장성]**
![image](https://user-images.githubusercontent.com/109563345/236936598-77872906-c32b-47c5-b2ae-417317a07a0e.png)

Kafka
파티션을 단일 노드에만 저장하고 추가 노드로 복제할 수 있습니다. 노드의 용량은 가장 작은 노드의 용량으로 제한됩니다.    
즉, 용량 확장에는 파티션 재조정이 필요하며, 이를 위해서는 새로 추가된 브로커에 대한 데이터와 트래픽의 균형을 맞추기 위해 전체 파티션을 다시 복사해야 합니다.    
데이터를 재복사하는 것은 비용이 많이 들고 오류가 발생하기 쉬우며 네트워크 대역폭과 I/O를 소모합니다. 작업자는 이 작업을 수행할 때 매우 주의해야 합니다. 그렇지 않으면 프로덕션 시스템이 쉽게 손상될 수 있습니다.

segmentation를 사용하면 Topic partition의 메시지를 클러스터의 모든 부키에 고르게 분산하고 균형을 맞출 수 있음     
즉, Topic partition의 용량이 노드 하나의 용량에 의해서만 제한되는 것은 아니라 전체 BookKeeper 클러스터의 총 용량으로 확장    

### **[스트림 처리]**



---
RabbitMQ는 세 가지 시스템 중 가장 낮은 지연 시간을 달성하지만 제한된 수직 확장성을 고려할 때 훨씬 낮은 처리량에 불과
