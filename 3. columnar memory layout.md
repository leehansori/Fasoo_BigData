---
layout: post
title: "columnar memory layout"
등록일: 2023-04-18
수정일: 2023-04-
author: 이한솔
---


## **목차**
1. parquet, arrow


---

parquet 인코딩/hybrid/shared shared nothing/lambda architecture    

---

## **행 지향 저장 방식 vs 열 지향 저장 방식**
1. 행 지향 저장 방식 : 행(row) 단위로 데이터를 쭉 이어서 저장하는 방식.    
    - RDB    
2. 열 지향 저장 방식 : 열(column) 단위로 데이터를 저장하는 방식. 컬럼 단위의 집계에 최적화.    
   - 열 지향 storage : Apache Cassandra, Apache HBase    
     열 지향 데이터 저장 format : Apache parquet, Apache orc    
   - **장점**
        - 디스크 I/O를 줄일 수 있음    
        : 필요한 컬럼만을 로드함. 행 지향은 행 단위로 저장되어 있어서 필요 없는 열까지 디스크로부터 로드.    
        ![image](https://user-images.githubusercontent.com/109563345/233277650-c7369dea-5406-4b42-ba55-908898b9f77d.png)
        - 데이터 압축 효율 우수    
        : 같은 컬럼에는 대부분 유사하거나 중복된 데이터가 나열됨     
            → 중복된 데이터를 압축해서 저장 가능. 특히 같은 문자열의 반복은 매우 작게 압축이 가능    

                ex) 데이터 압축 방법 (허프만 코딩)        
                : 데이터 문자가 얼마나 자주 출현하는지 빈도를 파악해 빈도수가 높은 기호에 짧은 접두어 코드를 부여     
                
                문자열 "aabbaabcd"    
                a(5번), b(3번), c(1번)와 d(1번) 이 순서대로 짧은 코드를 부여합니다. a=0, b=01, c=011, d=111    
                → 00001010001011111 으로 압축    
                압축 전의 문자열은 80비트 ⇒ 17비트로 21% 압축    
            
### **압축 방법**
1. Gzip
    - 속도 : 비교적 느린 속도
    - cpu 사용률 : 상대적으로 높음
    - 압축률 : 압축률이 높아 상대적으로 적은 용량 차지    
    → 사용 빈도가 낮거나 장기적 보존이 필요한 경우 적합해보임    
2. Snappy
    - 속도 : 빠른 압축, 해제 속도
    - cpu 사용률 : 상대적으로 낮음
    - 압축률 : 압축률이 낮아 상대적으로 많은 용량 차지    
    → 빈번하게 액세스되는 데이터 사용시 적합해보임. ex) 실시간 데이터 처리    
3. Zstd
    - Gzip과 비슷한 압축률이지만 속도가 빠름
    - 성능 비교가 필요한 것으로 보임

---

## **람다 아키텍처(Lambda Architecture)**
> 람다 아키텍처는 실시간 레이어와 배치 레이어를 결합하여 실시간 분석을 지원하는 아키텍처
ex) 배치 분석을 통해 일자별로 통계 생성, 당일 데이터는 별도의 실시간 통계를 유지한 다음, 이를 합쳐서 실시간 분석을 제공

### **등장 배경**
이전에는 데이터 처리를 위해 배치 처리(데이터를 모아두었다가, 일괄로 처리) 방식을 주로 이용함.    
하지만 배치 처리를 통해 실시간으로 분석하기 위해서는 대용량의 데이터를 쿼리해야하는데 많은 시간이 소요됨.    
이를 위해 **스트림 처리를 하는 스피드 레이어 + 배치 처리를 하는 배치 레이어**의 조합으로 어느정도의 실시간 분석을 지원.   
- 배치 처리 : 데이터를 모아두었다가, 특정 시간에 일괄로 처리하는 방식. 특히 배치는 보통 정해진 특정한 시간에 실행되는데 대개 하루가 끝날 때나 야간과 같이 컴퓨팅 리소스 사용량이 적은 시간에 태스크를 배치로 처리하여 시스템에 주는 부담을 줄일 수 있음.

### **람다 아키텍처**
![image](https://user-images.githubusercontent.com/109563345/233898926-3a545abb-1444-4019-9400-147df9bdeffa.png)
**1. 배치 레이어 (Batch Layer)**
- 데이터를 마스터 데이터셋에 저장 후 배치 처리. 
- 배치 처리의 결과는 배치 뷰를 통해 확인.
    - 마스터 데이터셋 : 데이터 처리 전의 raw Data 저장. 시간 순으로 데이터를 저장함. 저장, 조회만 가능하고 변경은 안되는 불변 데이터(immutable data) 구조를 갖음. **이는 데이터 수정, 삭제 시 생길 수 있는 데이터 유실, 불일치를 방지 할 수 있고 특정 시점의 데이터 값을 정확히 추출할 수 있는 장점**.    → 기존의 원본 데이터를 가지고 있어서 배치 뷰의 데이터가 부정확할 때 복구가 가능.
**2. 스피드 레이어 (Speed Layer)**
- 실시간 정보를 얻기 위해 스트림 처리. 배치 뷰에서 실시간 정보를 얻을 수 없기 때문에 배치 레이어에서 생기는 차이를 채우는 용도.    ex) 배치가 매일 자정마다 동작할 경우 당일 오후에는 해당 일자의 데이터를 확인할 수 없기에 실시간 집게    
- 실시간 처리의 결과는 실시간 뷰를 통해 확인.
- 배치 뷰가 업데이트될 동안까지만 이용되고, 오래된 데이터는 순서대로 삭제.
**3. 서빙 레이어 (Serving Layer)**
- 실시간 뷰 + 배치 뷰 조합시키는 형태로 쿼리 실행    ex) 실시간 뷰(최근 24시간의 집계 결과) + 배치 뷰(그 이전의 일일 데이터 배치 처리 집계 결과)


### **실시간 분석에 배치 레이어가 필요한 이유**
실시간 처리의 단점을 보완하기 위해서

### **장단점?**
### **오픈 소스의 조합**
배치 레이어에서 만든 배치 뷰 데이터와 스피드 레이어에서 만든 실시간 뷰의 데이터가 중복되지 않게 관리하는 것이 중요하다. 이 부분은 타임스탬프(timestamp)로 해결이 가능하다. 또한, 배치로 데이터가 만들어진 후에 실시간 뷰의 데이터를 주기적으로 지워주어야한다.


--- 

출처    
허프만 코딩 <https://nykim.work/93>    
압축 비교 <https://www.youtube.com/watch?v=EQhldyLWPwI>    
<http://wiki.hash.kr/index.php/%EB%9E%8C%EB%8B%A4_%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98#cite_note-.EC.B0.A8-1> , <http://bcho.tistory.com/984>
