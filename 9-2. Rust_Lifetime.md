## Lifetime
- 모든 참조자는 Lifetime을 갖음. 참조자가 유효한 범위
- 라이프타임 파라미터를 이용해 이 관계를 명시

### Lifetime이 필요한 이유
→ **dangling reference**를 방지하기 위해    
*dangling reference: 이미 할당 해제된 메모리를 참조자가 계속 가리키고 있는 경우    
```rust
{
    let r;
    {
        let x = 5;
        r = &x;
    }
    println!("r: {}", r);
}

error: `x` does not live long enough
```
→ r은 x가 스코프 밖으로 벗어났을 때 할당이 해제되는 메모리를 참조하게 될 것이고,    
r을 가지고 시도하려 했던 어떤 것이든 정확히 동작하지 않게 됨

### borrow checker
빌림 검사기(borrow checker) 라고 불리는 컴파일러의 부분이 모든 빌림이 유효한지를 결정하기 위해 스코프를 비교
```rust
{
    let r;         // -------+-- 'a
    {              //        |
        let x = 5; // -+-----+-- 'b
        r = &x;    //  |     |
    }              // -+     |
    println!("r: {}", r); // |
                   // -------+
}
```
➔ 참조자의 주체가 참조자보다 더 긴 Lifetime을 가져야함

### 라이프타임 명시
자연스럽게 스코프 비교가 되지 않는 경우 명시해야함
여러 개의 참조자에 대한 라이프타임들을 서로 연관 짓도록 하는 것
두 개의 같은 이름을 가진 라이프타임 명시는 참조자 first 와 second 가 둘 다 동일한 제네릭 라이프타임만큼 살아야 한다
```rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = String::from("xyz");

    let result = longest(&string1, &string2);
    println!("The longest string is {}", result);
}

fn longest(x: & str, y: & str) -> & str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

### 명시하지 않아도 되는 경우
