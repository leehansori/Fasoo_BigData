### rust에서 불변성과 가변성이 따로 있는 이유
Rust에서 불변성(Immutability)과 가변성(Mutability)은 메모리 안전성과 동시성을 보장하기 위해 구분되어 있습니다. 
이러한 구분은 Rust의 핵심 원칙 중 하나인 "대여 규칙(Borrowing Rules)"과 관련이 있습니다.
Rust는 안전하고 효율적인 메모리 관리를 위해 "소유권(Ownership)" 개념을 도입합니다. 
소유권은 한 개의 변수가 어떤 리소스(메모리 등)를 소유하고 해당 리소스에 대한 제어 권한을 가지는 것을 의미합니다. 
Rust에서 변수는 기본적으로 불변(immutable)입니다. 이는 변수에 할당된 값이 변경되지 않음을 의미합니다. 
불변 변수는 여러 개의 참조자(Reference)를 허용하고, 동시에 여러 개의 읽기 전용 참조자를 생성할 수 있습니다. 이는 Rust의 대여 규칙을 따라 여러 개의 읽기 전용 참조자가 동시에 존재할 때도 안전성을 보장합니다.
하지만 Rust는 가변성도 제공합니다. 가변 변수(mut variable)를 사용하면 변수의 값이 변경될 수 있습니다. 가변 변수는 단일 소유권을 가지며, 해당 변수에 대한 가변 참조자(mut reference)를 생성할 수 있습니다. 
가변 참조자는 읽기와 쓰기를 모두 허용하며, Rust의 대여 규칙을 따라 단일 가변 참조자만 생성할 수 있습니다. 이는 데이터 레이스(data races)와 같은 동시성 문제를 방지하고, 안전한 동시성 프로그래밍을 가능하게 합니다.
따라서, Rust에서 불변성과 가변성을 구분하는 이유는 안전한 메모리 관리와 동시성을 보장하기 위함입니다. 
불변성은 여러 개의 읽기 전용 참조자를 허용하고, 가변성은 단일 가변 참조자를 허용하여 동시성 문제를 방지하고 메모리 안전성을 유지합니다. 이러한 구분은 Rust의 주요 장점 중 하나로, 안전하고 효율적인 시스템 프로그래밍을 가능하게 합니다.

### 데이터 타입
1. 스칼라
   - 정수형    
     ![image](https://github.com/leehansori/Fasoo_BigData/assets/109563345/ea7f71af-e63d-4a98-8207-bf25efb152ee)    
     - Unsigned(미부호) : 오직 양수만
     - Rust의 기본 값인 i32가 일반적으로 가장 빠름
   - 부동 소수점 타입 : f32, f64    
     (기본 타입은 f64. 그 이유는 최신의 CPU 상에서는 f64가 f32와 대략 비슷한 속도를 내면서도 더 정밀한 표현이 가능)
   - Boolean 타입 : bool
   - 문자 타입 : char
     - String은 "", char는 ''
     - char와 String의 차이?
3. 복합
   - 튜플
     ```
      fn main() {
      let x: (i32, f64, u8) = (500, 6.4, 1);
      let five_hundred = x.0;
      let six_point_four = x.1;
      let one = x.2;
     }
     ```
   - 배열
     ```
     fn main() {
     let a = [1, 2, 3, 4, 5];
     }
     ```
